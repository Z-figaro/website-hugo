<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta itemprop="name" content="Go语言基础">
<meta itemprop="description" content="go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。">


<meta itemprop="datePublished" content="2018-12-19T15:38:14&#43;08:00" />
<meta itemprop="dateModified" content="2018-12-19T15:38:14&#43;08:00" />
<meta itemprop="wordCount" content="4243">



<meta itemprop="keywords" content="go," />
<meta property="og:title" content="Go语言基础" />
<meta property="og:description" content="go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://z-figaro.github.io/daily/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" />
<meta property="article:published_time" content="2018-12-19T15:38:14&#43;08:00"/>
<meta property="article:modified_time" content="2018-12-19T15:38:14&#43;08:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go语言基础"/>
<meta name="twitter:description" content="go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Go语言基础</title>
	<link rel="stylesheet" href="https://z-figaro.github.io/css/style.min.c693329ce3bac2503f88115a4011a284a06d53e30f484562a37664dc4c5f0a74.css" integrity="sha256-xpMynOO6wlA/iBFaQBGihKBtU+MPSEVio3Zk3ExfCnQ=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://z-figaro.github.io/">Figaro ZP</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://z-figaro.github.io/daily/">Daily</a>
					<a href="https://z-figaro.github.io/golang/">Golang</a>
					<a href="https://z-figaro.github.io/python/">Python</a>
					<a href="https://z-figaro.github.io/ios/">iOS</a>
					<a href="https://z-figaro.github.io/about-me/">About</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://www.facebook.com/zp.figaro.5" target="_blank" rel="noopener" title="Facebook"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></a><a href="zpfigaro@gmail.com" target="_blank" rel="noopener" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://github.com/Z-figaro" target="_blank" rel="noopener" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://z-figaro.github.io/daily/">Daily</a></li>
			<li><a href="https://z-figaro.github.io/golang/">Golang</a></li>
			<li><a href="https://z-figaro.github.io/python/">Python</a></li>
			<li><a href="https://z-figaro.github.io/ios/">iOS</a></li>
			<li><a href="https://z-figaro.github.io/about-me/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Go语言基础</h1>
		<div class="content">
			<p>go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。</p>

<h1 id="go语言基础">go语言基础<a href="#go语言基础" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<h2 id="go语言特性">GO语言特性<a href="#go语言特性" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>1.不用做内存管理
2.天然支持高并发
3.channel管道
    管道最初是unix中的特性，因为进程之间是隔离的，如果两个进程之间需要资源交互；那么就把资源放到管道中。通过管道交互。
4.多返回值</p>

<h2 id="go-语言的包引入一般为-项目名-包名">Go 语言的包引入一般为: 项目名/包名<a href="#go-语言的包引入一般为-项目名-包名" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p><code>import &quot;test/controllers&quot;</code>
方法的调用为: 包名.方法名()</p>

<p><code>controllers.Test()</code>
本包内方法名可为小写，包外调用方法名首字母必须为大写。</p>

<h2 id="fmt包">fmt包<a href="#fmt包" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>1.<strong>Print()</strong> 函数将参数列表 a 中的各个参数转换为字符串并写入到标准输出中。</p>

<p>非字符串参数之间会添加空格，返回写入的字节数。</p>

<p><code>func Print(a ...interface{}) (n int, err error)</code></p>

<p>2.<strong>Println()</strong> 函数功能类似 Print，只不过最后会添加一个换行符。</p>

<p>所有参数之间会添加空格，返回写入的字节数。</p>

<p><code>func Println(a ...interface{}) (n int, err error)</code></p>

<p>3.<strong><em>Printf()</em></strong> 函数将参数列表 a 填写到格式字符串 format 的占位符中。</p>

<p>填写后的结果写入到标准输出中，返回写入的字节数。</p>

<p><code>func Printf(format string, a ...interface{}) (n int, err error)</code></p>

<p>实例：</p>

<pre><code>   fmt.Print(&quot;a&quot;, &quot;b&quot;, 1, 2, 3, &quot;c&quot;, &quot;d&quot;, &quot;\n&quot;)
	fmt.Println(&quot;a&quot;, &quot;b&quot;, 1, 2, 3, &quot;c&quot;, &quot;d&quot;)
	fmt.Printf(&quot;ab %d %d %d cd\n&quot;, 1, 2, 3)
	fmt.Println(&quot;你好&quot;)
	
    ab1 2 3cd
    a b 1 2 3 c d
    ab 1 2 3 cd
    你好
</code></pre>

<h2 id="条件控制">条件控制<a href="#条件控制" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<ol>
<li>支持多条件匹配</li>
</ol>

<pre><code>switchswitch{{
         casecase  11,,22,,33,,44::
         defaultdefault::
 }}
</code></pre>

<ol>
<li><p>不同的 case 之间不使用 break 分隔，默认只会执行一个 case。</p></li>

<li><p>如果想要执行多个 case，需要使用 fallthrough 关键字，也可用 break 终止。</p></li>
</ol>

<pre><code>switch{
    case 1:
    ...
    if(...){
        break
    }

    fallthrough // 此时switch(1)会执行case1和case2，但是如果满足if条件，则只执行case1

    case 2:
    ...
    case 3:
}
</code></pre>

<h3 id="select-语句">select 语句<a href="#select-语句" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。</p>

<p>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p>

<p>以下描述了 select 语句的语法：</p>

<p>每个case都必须是一个通信
所有channel表达式都会被求值
所有被发送的表达式都会被求值
如果任意某个通信可以进行，它就执行；其他被忽略。
如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
否则：
如果有default子句，则执行该语句。
如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = &lt;-c1:
         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)
      case c2 &lt;- i2:
         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)
      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
         if ok {
            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)
         } else {
            fmt.Printf(&quot;c3 is closed\n&quot;)
         }
      default:
         fmt.Printf(&quot;no communication\n&quot;)
   }    
}
</code></pre>

<h2 id="函数">函数<a href="#函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<pre><code>func function_name( [parameter list] ) [return_types] {
   函数体
}
</code></pre>

<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200
   var ret int

   /* 调用函数并返回最大值 */
   ret = max(a, b)

   fmt.Printf( &quot;最大值是 : %d\n&quot;, ret )
}

/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 定义局部变量 */
   var result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</code></pre>

<h2 id="全局变量与局部变量">全局变量与局部变量<a href="#全局变量与局部变量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p>

<pre><code>package main

import &quot;fmt&quot;

/* 声明全局变量 */
var g int = 20

func main() {
   /* 声明局部变量 */
   var g int = 10

   fmt.Printf (&quot;结果： g = %d\n&quot;,  g)
}
</code></pre>

<p>一个更好的实例：</p>

<pre><code>package main

import &quot;fmt&quot;

/* 声明全局变量 */
var a int = 20

func main() {
    /* main 函数中声明局部变量 */
    var a int = 10
    var b int = 20
    var c int = 0

    fmt.Printf(&quot;main()函数中 a = %d\n&quot;, a)
    c = sum(a, b)
    fmt.Printf(&quot;main()函数中 a = %d\n&quot;, a)
    fmt.Printf(&quot;main()函数中 c = %d\n&quot;, c)
}

/* 函数定义-两数相加 */
func sum(a, b int) int {
    a = a + 1
    fmt.Printf(&quot;sum() 函数中 a = %d\n&quot;, a)
    fmt.Printf(&quot;sum() 函数中 b = %d\n&quot;, b)
    return a + b
}
</code></pre>

<p>结果：</p>

<pre><code>main()函数中 a = 10
sum() 函数中 a = 11
sum() 函数中 b = 20
main()函数中 a = 10
main()函数中 c = 31
</code></pre>

<h2 id="切片">切片<a href="#切片" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Go 语言切片是对数组的抽象。</p>

<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(&ldquo;动态数组&rdquo;),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>

<p>定义：
<code>var identifier []type</code></p>

<p>简写：
&gt; var slice1 []type = make([]type, len)</p>

<blockquote>
<p>也可以简写为</p>

<p>slice1 := make([]type, len)</p>
</blockquote>

<p>也可以指定容量，其中capacity为可选参数。
&gt; make([]T, length, capacity)</p>

<h3 id="切片初始化">切片初始化<a href="#切片初始化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<blockquote>
<p>s :=[] int {1,2,3 }
直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p>

<p>s := arr[:]
初始化切片s,是数组arr的引用</p>

<p>s := arr[startIndex:endIndex]
将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>

<p>s := arr[startIndex:]
缺省endIndex时将表示一直到arr的最后一个元素</p>

<p>s := arr[:endIndex]
缺省startIndex时将表示从arr的第一个元素开始</p>

<p>s1 := s[startIndex:endIndex]
通过切片s初始化切片s1</p>

<p>s :=make([]int,len,cap)
通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
</blockquote>

<h3 id="len-和-cap-函数">len() 和 cap() 函数<a href="#len-和-cap-函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>切片是可索引的，并且可以由 len() 方法获取长度。</p>

<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var numbers = make([]int,3,5)

   printSlice(numbers)
}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=3 cap=5 slice=[0 0 0]
</code></pre>

<h3 id="切片截取">切片截取<a href="#切片截取" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>可以通过设置下限及上限来设置截取切片 [lower-bound:upper-bound]，实例如下</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   /* 创建切片 */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)

   /* 打印原始切片 */
   fmt.Println(&quot;numbers ==&quot;, numbers)

   /* 打印子切片从索引1(包含) 到索引4(不包含)*/
   fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4])

   /* 默认下限为 0*/
   fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3])

   /* 默认上限为 len(s)*/
   fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:])

   numbers1 := make([]int,0,5)
   printSlice(numbers1)

   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */
   number2 := numbers[:2]
   printSlice(number2)

   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */
   number3 := numbers[2:5]
   printSlice(number3)

}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]
numbers == [0 1 2 3 4 5 6 7 8]
numbers[1:4] == [1 2 3]
numbers[:3] == [0 1 2]
numbers[4:] == [4 5 6 7 8]
len=0 cap=5 slice=[]
len=2 cap=9 slice=[0 1]
len=3 cap=7 slice=[2 3 4]
</code></pre>

<h3 id="append-和-copy-函数">append() 和 copy() 函数<a href="#append-和-copy-函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>

<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var numbers []int
   printSlice(numbers)

   /* 允许追加空切片 */
   numbers = append(numbers, 0)
   printSlice(numbers)

   /* 向切片添加一个元素 */
   numbers = append(numbers, 1)
   printSlice(numbers)

   /* 同时添加多个元素 */
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)

   /* 创建切片 numbers1 是之前切片的两倍容量*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)

   /* 拷贝 numbers 的内容到 numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=0 cap=0 slice=[]
len=1 cap=1 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=6 slice=[0 1 2 3 4]
len=5 cap=12 slice=[0 1 2 3 4]

</code></pre>

<h3 id="范围range">范围Range<a href="#范围range" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。</p>

<h2 id="map">map<a href="#map" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>

<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>

<p>/* 声明变量，默认 map 是 nil */
&gt; var map_variable map[key_data_type]value_data_type</p>

<p>/* 使用 make 函数 */
&gt; map_variable := make(map[key_data_type]value_data_type)</p>

<p><strong>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</strong></p>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    var countryCapitalMap map[string]string /*创建集合 */
    countryCapitalMap = make(map[string]string)

    /* map插入key - value对,各个国家对应的首都 */
    countryCapitalMap [ &quot;France&quot; ] = &quot;Paris&quot;
    countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;
    countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;
    countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;

    /*使用键输出地图值 */ for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])
    }

    /*查看元素在集合中是否存在 */
    captial, ok := countryCapitalMap [ &quot;美国&quot; ] /*如果确定是真实的,则存在,否则不存在 */
    /*fmt.Println(captial) */
    /*fmt.Println(ok) */
    if (ok) {
        fmt.Println(&quot;美国的首都是&quot;, captial)
    } else {
        fmt.Println(&quot;美国的首都不存在&quot;)
    }
}

结果：
France 首都是 Paris
Italy 首都是 罗马
Japan 首都是 东京
India  首都是 新德里
美国的首都不存在
</code></pre>

<h3 id="delete-函数">delete() 函数<a href="#delete-函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    /* 创建map */
    countryCapitalMap := map[string]string{&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;}

    fmt.Println(&quot;原始地图&quot;)

    /* 打印地图 */
    for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])
    }

    /*删除元素*/ delete(countryCapitalMap, &quot;France&quot;)
    fmt.Println(&quot;法国条目被删除&quot;)

    fmt.Println(&quot;删除元素后地图&quot;)

    /*打印地图*/
    for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])
    }
}

结果：
原始地图
India 首都是 New delhi
France 首都是 Paris
Italy 首都是 Rome
Japan 首都是 Tokyo
法国条目被删除
删除元素后地图
Italy 首都是 Rome
Japan 首都是 Tokyo
India 首都是 New delhi
</code></pre>

<h2 id="递归函数">递归函数<a href="#递归函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<pre><code>func recursion() {
   recursion() /* 函数调用自身 */
}

func main() {
   recursion()
}
</code></pre>

<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>

<p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等</p>

<pre><code>package main

import &quot;fmt&quot;

func fibonacci(n int) int {
  if n &lt; 2 {
   return n
  }
  return fibonacci(n-2) + fibonacci(n-1)
}

func main() {
    var i int
    for i = 0; i &lt; 10; i++ {
       fmt.Printf(&quot;%d\t&quot;, fibonacci(i))
    }
}

结果：
0    1    1    2    3    5    8    13    21    34
</code></pre>

<h2 id="类型转换">类型转换<a href="#类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<blockquote>
<p>type_name(expression)</p>
</blockquote>

<p><strong>type_name 为类型，expression 为表达式。</strong></p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var sum int = 17
   var count int = 5
   var mean float32
   
   mean = float32(sum)/float32(count)
   fmt.Printf(&quot;mean 的值为: %f\n&quot;,mean)
}

结果：
mean 的值为: 3.400000
</code></pre>

<h2 id="接口">接口<a href="#接口" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>

<p>表达：</p>

<pre><code>/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
</code></pre>

<p>实例：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println(&quot;I am Nokia, I can call you!&quot;)
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println(&quot;I am iPhone, I can call you!&quot;)
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call()

    phone = new(IPhone)
    phone.call()

}

在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：

I am Nokia, I can call you!
I am iPhone, I can call you!
</code></pre>

<h2 id="错误处理">错误处理<a href="#错误处理" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<pre><code>type error interface {
    Error() string
}
</code></pre>

<p>这是定义。</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

// 定义一个 DivideError 结构
type DivideError struct {
    dividee int
    divider int
}

// 实现 `error` 接口
func (de *DivideError) Error() string {
    strFormat := `
    Cannot proceed, the divider is zero.
    dividee: %d
    divider: 0
`
    return fmt.Sprintf(strFormat, de.dividee)
}

// 定义 `int` 类型除法运算的函数
func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
    if varDivider == 0 {
        dData := DivideError{
            dividee: varDividee,
            divider: varDivider,
        }
        errorMsg = dData.Error()
        return
    } else {
        return varDividee / varDivider, &quot;&quot;
    }

}

func main() {

    // 正常情况
    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; {
        fmt.Println(&quot;100/10 = &quot;, result)
    }
    // 当被除数为零的时候会返回错误信息
    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; {
        fmt.Println(&quot;errorMsg is: &quot;, errorMsg)
    }

}

结果：
100/10 =  10
errorMsg is:  
    Cannot proceed, the divider is zero.
    dividee: 100
    divider: 0
</code></pre>
		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://z-figaro.github.io/">Figaro ZP</a> &#183; <a href="https://creativecommons.org/licenses/by-figaro zp" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://z-figaro.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://z-figaro.github.io/js/main.min.8f39f24808e9d0a9b02da58c2d2838da859dc0b7bdfadbdb1883aae8b6adacfe.js" integrity="sha256-jznySAjp0KmwLaWMLSg42oWdwLe9+tvbGIOq6LatrP4="></script>

</body>

</html>
